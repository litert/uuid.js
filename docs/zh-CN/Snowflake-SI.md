# Snowflake-SI 算法

Snowflake-SI 算法是 Snowflake 算法的变种。标准的 Snowflake 算法使用的是 64 位整数，
而 ECMAScript 中无法使用 64 位整数。因为在其语言规范里规定，只有取值范围在
`Number.MIN_SAFE_INTEGER ~ Number.MAX_SAFE_INTEGER` 之间的整数是精确的，超出则
不再保证准确性。**因此在 ECMAScript 中能使用的整数只有 53 位、**

Snowflake-SI 算法为了确保生成的 UUID 的精度，于是使用了 53 位整数作为 UUID 的生成
结果，其位分部如下（默认规则）：

| H |                  52 ~ 13                 | 12 ~ 8 |   7 ~ 0  | L |
|:-:|:----------------------------------------:|:------:|:--------:|:-:|
|   | 1111111111111111111111111111111111111111 | 11111  | 11111111 |   |
|   |                   MAB                    |  MID   |   UIN    |   |

如上表，低 8 位是 UUID 序号（UIN，UUID Index Number），取自一个递增序列的低八位。从而
确保毫秒内即使生成 256 个 UUID 也不会重复。

> 理论上 Node.js 单机也无法处理一毫秒 256 个业务请求，因此 256 作为一毫秒内可生成
> UUID 的容量，在一般情况下是绰绰有余的。（如果 256 不够，可以看下一节“算法微调”）

低 8 ~ 12 位是机器序号（Machine ID），用于确保在分布式服务中，多个实例同时工作，也不会
生成重复的 UUID。此处只有 5 位，因此最多允许 32 个实例同时工作。

高 40 位是业务时钟（MAB，Milliseconds after base-clock）。要理解业务时钟，首先要确定
一个时间叫业务基准时间（Base-Clock），也就是这个 UUID 生成器开始使用的时间，一般是指
业务正式开始运行的时间。业务基准时间一旦确认就不能再更改。业务时钟是指当前时间减去
业务基准时间后，剩余的毫秒数。

> 按照现行 Unix 时间戳能表示的最大时间 `2038-01-19T03:14:07Z` 来算，也就是
> `0x7FFFFFFF`，换算成毫秒就是 `2147483647000`，使用了 41 位。而上面 MAB 只分配了
> 40 位，所以这对业务基准时间就有了一定的要求，即 Base-Cloud 必须满足条件：
> `2147483647000 - BaseClock < Math.pow(2, 40)`，从而可以得出 
> `BC > 1047972019224`。也就是说，业务基准时间必须在 `2003-03-18T07:20:19.224Z`
> 之后。

## 算法微调

如上所述，高 40 位作为业务时钟是固定的，而剩下的 13 位却是可以调整的。例如，如果业务
不需要分布式部署，那么就可以将整个 13 位当作毫秒容量，使之达到 8192。

不仅如此，如果将业务时钟的位宽调整为 41 位，那么业务基准时间就可以更早一些，
但同时每毫秒的 UUID 生成容量和机器序号的位宽也会相应减少。这些都是可以根据
实际业务需求进行调整的。
